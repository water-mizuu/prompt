// ignore_for_file: prefer_void_to_null

import "dart:async";

import "package:prompt/prompt.dart";
import "package:prompt/src/io/stdio/codes.dart";

Future<void> sleep(Duration duration) => Future<void>.delayed(duration);

int? get terminalColumns {
  if (stdout.hasTerminal) {
    return stdout.terminalColumns;
  }
}

extension StdoutExtension on WrappedStdout {
  /// Writes a space character to the standard output.
  void space() {
    write(" ");
  }

  /// Escapes the given [value] with the ANSI escape code.
  String escape(String value) => "$escapeCode$value";

  /// Writes the given [value] to the standard output, escaping it with the ANSI escape code.
  void writeEscaped(String value) {
    write(escape(value));
  }

  /// Rings the terminal bell.
  void bell() {
    write(bellCode);
  }

  /// Resets the foreground color of the current context to the default.
  void resetForegroundColor() {
    contextStack.last.foregroundColor = Color.reset;
    update();
  }

  /// Resets the foreground color of the background context to the default.
  void resetBackgroundColor() {
    contextStack.last.backgroundColor = Color.reset;
    update();
  }

  void setForegroundColor(Color color) {
    contextStack.last.foregroundColor = color;
    update();
  }

  void setBackgroundColor(Color color) {
    contextStack.last.backgroundColor = color;
    update();
  }

  void resetColor() {
    resetBackgroundColor();
    resetForegroundColor();
  }

  void eraselnPrev() {
    moveUp();
    eraseln();
  }

  void eraseScreen() {
    write(eraseCode);
  }

  void eraseln() {
    writeEscaped(eraseLineCode);
    movelnStart();
  }

  void eraselnFromCursor() {
    writeEscaped(eraseLineFromCursorCode);
  }

  void eraselnToCursor() {
    writeEscaped(eraseLineToCursorCode);
  }

  void eraselnUp([int n = 1]) {
    eraseln();
    for (int i = 0; i < n; i++) {
      moveUp();
      eraseln();
    }
    moveDown(n);
  }

  void eraselnDown([int n = 1]) {
    eraseln();
    for (int i = 0; i < n; i++) {
      moveDown();
      eraseln();
    }
    moveUp(n);
  }

  /// Converts [object] to a String by invoking [Object.toString] and
  /// [add]s the encoding of the result to the target consumer.
  /// **The cursor is not moved by this write**.
  ///
  /// This operation is non-blocking. See [flush] or [done] for how to get any
  /// errors generated by this call.
  void write$(Object object) {
    String string = object.toString();

    if (string.isNotEmpty) {
      if (hasTerminal) {
        var (:int column, line: _) = cursor;
        writeln(string);
        moveUp();
        moveRight(column);
      } else {
        write(string);
        moveLeft(string.visibleLength);
      }
    }
  }

  void writeln$([Object object = ""]) {
    write$(object);
    moveDown();
  }

  void saveCursor() {
    write("${esc}7");
  }

  void restoreCursor() {
    write("${esc}8");
  }

  void moveVertical([int n = 0]) {
    switch (n) {
      case < 0:
        moveUp(-n);
      case > 0:
        moveDown(n);
    }
  }

  void moveHorizontal([int n = 0]) {
    switch (n) {
      case < 0:
        moveLeft(-n);
      case > 0:
        moveRight(n);
    }
  }

  void moveUp([int n = 1]) {
    if (n > 0) {
      writeEscaped("$n$moveUpCode");
    }
  }

  void moveDown([int n = 1]) {
    if (n > 0) {
      writeEscaped("$n$moveDownCode");
    }
  }

  void moveRight([int n = 1]) {
    if (n > 0) {
      writeEscaped("$n$moveRightCode");
    }
  }

  void moveLeft([int n = 1]) {
    if (n > 0) {
      writeEscaped("$n$moveLeftCode");
    }
  }

  void moveln(int n) {
    switch (n) {
      case < 0:
        movelnUp(-n);
      case > 0:
        movelnDown(n);
    }
  }

  void movelnUp([int n = 1]) {
    if (n < 1) {
      return;
    }

    writeEscaped("$n$moveUpLineCode");
  }

  void movelnDown([int n = 1]) {
    if (n < 1) {
      return;
    }
    writeEscaped("$n$moveDownLineCode");
  }

  void movelnStart() {
    writeEscaped("1$moveToColumnCode");
  }

  void movelnEnd() {
    writeEscaped("${(terminalColumns ?? 80) + 1}$moveToColumnCode");
  }

  // ignore: prefer_expression_function_bodies
  ({int line, int column}) get cursor {
    return stdin.raw.returns(() {
      writeEscaped("6n");
      StringBuffer buffer = StringBuffer();

      for (int i = 0; i < 16; ++i) {
        int readByte = stdin.readByteSync();
        if (readByte < 0) break; // headless console may not report back
        if (readByte == 0x52) break; // R = end of CPR result

        // ignore: use_string_buffers
        buffer.write(String.fromCharCode(readByte));
      }

      var [String y, String x] = buffer.toString().substring(2).split(";");

      return (line: int.parse(y) - 1, column: int.parse(x) - 1);
    });
  }

  // Overloads
  void set foregroundColor(Color color) => setForegroundColor(color);
  void set backgroundColor(Color color) => setBackgroundColor(color);
}
